//1065
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	int num, i, j = 0, k, p, cnt = 0, remainder[5];

	scanf("%d", &num);
	for (i = 1; i <= num; i++) {

		//2자리수 일 때는 무조건 한수(그 전에 비교할 수가 없기 때문)이기에 2자리&3자리이상 으로 나눈 것
		if (i<100) {
			cnt=i;
		}

		//3자리수부터는 따져줘야 함
		else {
			k = i; //i는 나중에 i++되어야 하므로 값 보존해야 함.
			j = 0; //이 포인트에서 j 초기화 중요 (안그러면 i++되는 동안 j 누적되서 나옴)
			
			//n자리수의 각 자리숫자들을 분리해서 배열에 담기 위한 코드 (한 자리씩 등차수열 여부 비교해야 해서~)
			while (k != k%10) {
				remainder[j] = k % 10;
				k=k/10;
				j++;
				if (k < 10) {
					remainder[j] = k;
				}
			}

			//an,an-1,an-2 점화식 비교하듯 각 자릿수 등차수열 여부 판단 후 cnt에 반영하는 과정
			for (p = 0; p+2 < j+1; p++) {
				if (remainder[p + 2] - remainder[p + 1] == remainder[p + 1] - remainder[p]) {
					if (p + 2 == j) {
						cnt++;
					}
				}
			}
		}
	}
	printf("%d", cnt);
	return 0;
}
/* 변수 초기화
Run-Time Check Failure #2 - Stack around the variable '????' was corrupted.
>>설정한 배열보다 더 많은 배열을 넣으려고 했을 때 나는 오류 (의도치 않게 더 들어간 데이터 없나 코드 흐름 확인하기)

while문 끝나는 부분에 printf("(%d)",j) 로 확인하니 j가
         (j)
(0)(0)(1)(2)
(1)(0)(1)(4)
(2)(0)(1)(6)
(3)(0)(1)(8)
(4)(0)(1)(10)
(5)(0)(1)(12)
(6)(0)(1)(14)
(7)(0)(1)(16)
(8)(0)(1)(18)
(9)(0)(1)(20)
(0)(1)(1)(22)
22까지 헛도는 거 확인함, i가 +1로 초기화될 떄 j도 0으로 초기화 해줬어야 함.
해결: else문 시작할 때 j = 0로 j 초기화시켜주기
*/

/* 논리 오류
for (p = 0; p+2 < j+1; p++) {
	if (remainder[p + 2] - remainder[p + 1] == remainder[p + 1] - remainder[p]) {
		cnt++;
	}
}
이 코드는 3자리수만 한수 검사 가능
>>3자리면 p=0에서 멈추니까, 근데 4자리면 3자리수까지 검사한 거 바탕으로 한수 판단하니까 1000일 때 000으로 봐서 cnt++ 작동한 거였음.
해결: (위에 코드 참고, p+2가 마지막까지 가야지 cnt++ 하게 만들기)
*/

/*
(c언어와 파이썬 변수할당 원리의 차이점): '원리'가 이렇구나 정도만 알고 넘기기 (i,j 종속 독립은 상관없음. 때에 따라 달라지는거라~)
i=10
j=i

c언어: 변수가 '값'을 직접 저장 ex) i 값인 10을 j에 복사하는 것 
파이썬: 변수가 '무슨 값을 가르키는지(값을 가르키는 화살표 역할)' 저장 ex) i 값인 10을 j도 포인팅하게 됨 (그렇다고 무조건 j는 i에 종속을 아님~)
*/